## rv64中断介绍

> ** [info] 中断相关寄存器 **
> 
> 当我们触发中断进入S态进行处理时，以下寄存器会被硬件自动设置：
> 
> **sepc**(exception program counter)，它会记录触发中断的那条指令的**虚拟地址**；
> 
> **scause**，它会记录中断发生的原因，还会记录该中断是不是一个外部中断；
> 
> **stval**，它会记录一些中断处理所需要的辅助信息，比如取指、访存、缺页异常，它会把发生问题的目标地址记录下来，这样我们在处理程序中就知道处理目标了。
> 
> 还有一些中断配置的寄存器：
> 
> **stvec**，设置如何寻找中断处理程序，保存了中断向量表基址BASE，同时还有模式MODE。
> 
> 当$$\text{MODE}=0$$，设置为 Direct 模式时，无论中断因何发生我们都直接跳转到基址$$\text{pc}=\text{BASE}$$。
> 
> 当$$\text{MODE}=1$$时，设置为 Vectored 模式时，遇到中断我们会进行跳转如下：$$\text{pc}=\text{BASE}+4\times\text{cause}$$。而这样，我们只需将各中断处理程序放在正确的位置，并设置好 stvec ，遇到中断的时候硬件根据中断原因就会自动跳转到对应的中断处理程序了；
> 
> **sstatus**，一个状态寄存器。

我们再来看一下中断相关的指令。
> ** [info] 中断相关指令 **
> 
> **ecall**(environment call)，当我们在S态执行这条指令的话，会触发一个ecall-from-s-mode-exception，从而进入中断处理流程，常用来进行系统调用；
> 
> **ebreak**(environment break)，执行这条指令会触发一个断点中断从而进入中断处理流程；
> 
> **sret**，用于S态中断返回，实际作用为$$\text{pc}=\text{sepc}$$，回顾**sepc**定义，返回到通过中断进入S态之前的地址。
